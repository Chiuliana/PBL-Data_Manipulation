# Generated from Expr.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,35,193,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,1,0,4,0,54,
        8,0,11,0,12,0,55,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,66,8,1,1,2,
        1,2,1,2,1,2,4,2,72,8,2,11,2,12,2,73,1,2,1,2,1,3,1,3,1,3,1,4,1,4,
        1,4,1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,6,1,6,5,6,93,8,6,10,6,12,6,96,
        9,6,1,7,1,7,1,7,1,8,1,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,
        1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,1,12,1,12,1,12,
        1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,15,
        1,15,1,15,1,15,1,16,1,16,1,17,1,17,3,17,146,8,17,1,18,1,18,1,18,
        1,18,3,18,152,8,18,1,19,1,19,5,19,156,8,19,10,19,12,19,159,9,19,
        1,20,1,20,5,20,163,8,20,10,20,12,20,166,9,20,1,21,1,21,1,21,1,21,
        1,22,1,22,3,22,174,8,22,1,23,1,23,4,23,178,8,23,11,23,12,23,179,
        1,24,1,24,5,24,184,8,24,10,24,12,24,187,9,24,1,24,1,24,1,25,1,25,
        1,25,0,0,26,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,
        38,40,42,44,46,48,50,0,4,1,0,8,11,1,0,22,23,1,0,28,29,1,0,30,31,
        185,0,53,1,0,0,0,2,65,1,0,0,0,4,67,1,0,0,0,6,77,1,0,0,0,8,80,1,0,
        0,0,10,86,1,0,0,0,12,90,1,0,0,0,14,97,1,0,0,0,16,100,1,0,0,0,18,
        102,1,0,0,0,20,112,1,0,0,0,22,118,1,0,0,0,24,122,1,0,0,0,26,129,
        1,0,0,0,28,132,1,0,0,0,30,137,1,0,0,0,32,141,1,0,0,0,34,145,1,0,
        0,0,36,151,1,0,0,0,38,153,1,0,0,0,40,160,1,0,0,0,42,167,1,0,0,0,
        44,173,1,0,0,0,46,175,1,0,0,0,48,181,1,0,0,0,50,190,1,0,0,0,52,54,
        3,2,1,0,53,52,1,0,0,0,54,55,1,0,0,0,55,53,1,0,0,0,55,56,1,0,0,0,
        56,1,1,0,0,0,57,66,3,4,2,0,58,66,3,6,3,0,59,66,3,8,4,0,60,66,3,10,
        5,0,61,66,3,18,9,0,62,66,3,20,10,0,63,66,3,22,11,0,64,66,3,24,12,
        0,65,57,1,0,0,0,65,58,1,0,0,0,65,59,1,0,0,0,65,60,1,0,0,0,65,61,
        1,0,0,0,65,62,1,0,0,0,65,63,1,0,0,0,65,64,1,0,0,0,66,3,1,0,0,0,67,
        68,5,1,0,0,68,69,5,32,0,0,69,71,5,2,0,0,70,72,3,12,6,0,71,70,1,0,
        0,0,72,73,1,0,0,0,73,71,1,0,0,0,73,74,1,0,0,0,74,75,1,0,0,0,75,76,
        5,3,0,0,76,5,1,0,0,0,77,78,5,4,0,0,78,79,5,32,0,0,79,7,1,0,0,0,80,
        81,5,5,0,0,81,82,5,32,0,0,82,83,5,2,0,0,83,84,3,14,7,0,84,85,5,3,
        0,0,85,9,1,0,0,0,86,87,5,6,0,0,87,88,5,32,0,0,88,89,5,32,0,0,89,
        11,1,0,0,0,90,94,3,14,7,0,91,93,5,7,0,0,92,91,1,0,0,0,93,96,1,0,
        0,0,94,92,1,0,0,0,94,95,1,0,0,0,95,13,1,0,0,0,96,94,1,0,0,0,97,98,
        5,32,0,0,98,99,3,16,8,0,99,15,1,0,0,0,100,101,7,0,0,0,101,17,1,0,
        0,0,102,103,5,12,0,0,103,104,5,32,0,0,104,105,5,2,0,0,105,106,3,
        38,19,0,106,107,5,3,0,0,107,108,5,13,0,0,108,109,5,2,0,0,109,110,
        3,40,20,0,110,111,5,3,0,0,111,19,1,0,0,0,112,113,5,14,0,0,113,114,
        5,32,0,0,114,115,5,15,0,0,115,116,3,42,21,0,116,117,3,26,13,0,117,
        21,1,0,0,0,118,119,5,16,0,0,119,120,5,32,0,0,120,121,3,26,13,0,121,
        23,1,0,0,0,122,123,5,17,0,0,123,124,3,44,22,0,124,125,5,18,0,0,125,
        126,5,32,0,0,126,127,3,28,14,0,127,128,3,26,13,0,128,25,1,0,0,0,
        129,130,5,19,0,0,130,131,3,30,15,0,131,27,1,0,0,0,132,133,5,20,0,
        0,133,134,5,32,0,0,134,135,5,21,0,0,135,136,3,30,15,0,136,29,1,0,
        0,0,137,138,3,34,17,0,138,139,3,32,16,0,139,140,3,34,17,0,140,31,
        1,0,0,0,141,142,7,1,0,0,142,33,1,0,0,0,143,146,5,32,0,0,144,146,
        3,36,18,0,145,143,1,0,0,0,145,144,1,0,0,0,146,35,1,0,0,0,147,152,
        3,46,23,0,148,152,3,48,24,0,149,152,3,50,25,0,150,152,5,24,0,0,151,
        147,1,0,0,0,151,148,1,0,0,0,151,149,1,0,0,0,151,150,1,0,0,0,152,
        37,1,0,0,0,153,157,5,32,0,0,154,156,5,7,0,0,155,154,1,0,0,0,156,
        159,1,0,0,0,157,155,1,0,0,0,157,158,1,0,0,0,158,39,1,0,0,0,159,157,
        1,0,0,0,160,164,3,36,18,0,161,163,5,7,0,0,162,161,1,0,0,0,163,166,
        1,0,0,0,164,162,1,0,0,0,164,165,1,0,0,0,165,41,1,0,0,0,166,164,1,
        0,0,0,167,168,5,32,0,0,168,169,5,25,0,0,169,170,3,36,18,0,170,43,
        1,0,0,0,171,174,5,26,0,0,172,174,3,38,19,0,173,171,1,0,0,0,173,172,
        1,0,0,0,174,45,1,0,0,0,175,177,5,27,0,0,176,178,5,33,0,0,177,176,
        1,0,0,0,178,179,1,0,0,0,179,177,1,0,0,0,179,180,1,0,0,0,180,47,1,
        0,0,0,181,185,5,28,0,0,182,184,8,2,0,0,183,182,1,0,0,0,184,187,1,
        0,0,0,185,183,1,0,0,0,185,186,1,0,0,0,186,188,1,0,0,0,187,185,1,
        0,0,0,188,189,5,28,0,0,189,49,1,0,0,0,190,191,7,3,0,0,191,51,1,0,
        0,0,11,55,65,73,94,145,151,157,164,173,179,185
    ]

class ExprParser ( Parser ):

    grammarFileName = "Expr.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'create_table'", "'('", "')'", "'drop_table'", 
                     "'add_column'", "'remove_column'", "','", "'int'", 
                     "'string'", "'bool'", "'date'", "'insert_into'", "'values'", 
                     "'update'", "'set'", "'delete_from'", "'select'", "'from'", 
                     "'where'", "'join'", "'on'", "'and'", "'or'", "'null'", 
                     "'='", "'*'", "'-'", "'\"'", "'\\'", "'true'", "'false'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "' '" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "IDENTIFIER", "DIGIT", "NEWLINE", "SPACE" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_create_table_statement = 2
    RULE_drop_table_statement = 3
    RULE_add_column_statement = 4
    RULE_remove_column_statement = 5
    RULE_column_def_list = 6
    RULE_column_def = 7
    RULE_data_type = 8
    RULE_insert_statement = 9
    RULE_update_statement = 10
    RULE_delete_statement = 11
    RULE_select_statement = 12
    RULE_where_clause = 13
    RULE_join_clause = 14
    RULE_condition = 15
    RULE_logical_operator = 16
    RULE_expression = 17
    RULE_value = 18
    RULE_identifier_list = 19
    RULE_value_list = 20
    RULE_assignment_list = 21
    RULE_selection = 22
    RULE_numerical_literal = 23
    RULE_string_literal = 24
    RULE_boolean_literal = 25

    ruleNames =  [ "program", "statement", "create_table_statement", "drop_table_statement", 
                   "add_column_statement", "remove_column_statement", "column_def_list", 
                   "column_def", "data_type", "insert_statement", "update_statement", 
                   "delete_statement", "select_statement", "where_clause", 
                   "join_clause", "condition", "logical_operator", "expression", 
                   "value", "identifier_list", "value_list", "assignment_list", 
                   "selection", "numerical_literal", "string_literal", "boolean_literal" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    IDENTIFIER=32
    DIGIT=33
    NEWLINE=34
    SPACE=35

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExprParser.StatementContext)
            else:
                return self.getTypedRuleContext(ExprParser.StatementContext,i)


        def getRuleIndex(self):
            return ExprParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = ExprParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 52
                self.statement()
                self.state = 55 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 217202) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def create_table_statement(self):
            return self.getTypedRuleContext(ExprParser.Create_table_statementContext,0)


        def drop_table_statement(self):
            return self.getTypedRuleContext(ExprParser.Drop_table_statementContext,0)


        def add_column_statement(self):
            return self.getTypedRuleContext(ExprParser.Add_column_statementContext,0)


        def remove_column_statement(self):
            return self.getTypedRuleContext(ExprParser.Remove_column_statementContext,0)


        def insert_statement(self):
            return self.getTypedRuleContext(ExprParser.Insert_statementContext,0)


        def update_statement(self):
            return self.getTypedRuleContext(ExprParser.Update_statementContext,0)


        def delete_statement(self):
            return self.getTypedRuleContext(ExprParser.Delete_statementContext,0)


        def select_statement(self):
            return self.getTypedRuleContext(ExprParser.Select_statementContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = ExprParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 65
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [1]:
                self.enterOuterAlt(localctx, 1)
                self.state = 57
                self.create_table_statement()
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 2)
                self.state = 58
                self.drop_table_statement()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 3)
                self.state = 59
                self.add_column_statement()
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 4)
                self.state = 60
                self.remove_column_statement()
                pass
            elif token in [12]:
                self.enterOuterAlt(localctx, 5)
                self.state = 61
                self.insert_statement()
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 6)
                self.state = 62
                self.update_statement()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 7)
                self.state = 63
                self.delete_statement()
                pass
            elif token in [17]:
                self.enterOuterAlt(localctx, 8)
                self.state = 64
                self.select_statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_table_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ExprParser.IDENTIFIER, 0)

        def column_def_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExprParser.Column_def_listContext)
            else:
                return self.getTypedRuleContext(ExprParser.Column_def_listContext,i)


        def getRuleIndex(self):
            return ExprParser.RULE_create_table_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_table_statement" ):
                listener.enterCreate_table_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_table_statement" ):
                listener.exitCreate_table_statement(self)




    def create_table_statement(self):

        localctx = ExprParser.Create_table_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_create_table_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67
            self.match(ExprParser.T__0)
            self.state = 68
            self.match(ExprParser.IDENTIFIER)
            self.state = 69
            self.match(ExprParser.T__1)
            self.state = 71 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 70
                self.column_def_list()
                self.state = 73 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==32):
                    break

            self.state = 75
            self.match(ExprParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_table_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ExprParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return ExprParser.RULE_drop_table_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_table_statement" ):
                listener.enterDrop_table_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_table_statement" ):
                listener.exitDrop_table_statement(self)




    def drop_table_statement(self):

        localctx = ExprParser.Drop_table_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_drop_table_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self.match(ExprParser.T__3)
            self.state = 78
            self.match(ExprParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Add_column_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ExprParser.IDENTIFIER, 0)

        def column_def(self):
            return self.getTypedRuleContext(ExprParser.Column_defContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_add_column_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd_column_statement" ):
                listener.enterAdd_column_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd_column_statement" ):
                listener.exitAdd_column_statement(self)




    def add_column_statement(self):

        localctx = ExprParser.Add_column_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_add_column_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self.match(ExprParser.T__4)
            self.state = 81
            self.match(ExprParser.IDENTIFIER)
            self.state = 82
            self.match(ExprParser.T__1)
            self.state = 83
            self.column_def()
            self.state = 84
            self.match(ExprParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Remove_column_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(ExprParser.IDENTIFIER)
            else:
                return self.getToken(ExprParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return ExprParser.RULE_remove_column_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemove_column_statement" ):
                listener.enterRemove_column_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemove_column_statement" ):
                listener.exitRemove_column_statement(self)




    def remove_column_statement(self):

        localctx = ExprParser.Remove_column_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_remove_column_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self.match(ExprParser.T__5)
            self.state = 87
            self.match(ExprParser.IDENTIFIER)
            self.state = 88
            self.match(ExprParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_def_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_def(self):
            return self.getTypedRuleContext(ExprParser.Column_defContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_column_def_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_def_list" ):
                listener.enterColumn_def_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_def_list" ):
                listener.exitColumn_def_list(self)




    def column_def_list(self):

        localctx = ExprParser.Column_def_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_column_def_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 90
            self.column_def()
            self.state = 94
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==7:
                self.state = 91
                self.match(ExprParser.T__6)
                self.state = 96
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_defContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ExprParser.IDENTIFIER, 0)

        def data_type(self):
            return self.getTypedRuleContext(ExprParser.Data_typeContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_column_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_def" ):
                listener.enterColumn_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_def" ):
                listener.exitColumn_def(self)




    def column_def(self):

        localctx = ExprParser.Column_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_column_def)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self.match(ExprParser.IDENTIFIER)
            self.state = 98
            self.data_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Data_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ExprParser.RULE_data_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_type" ):
                listener.enterData_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_type" ):
                listener.exitData_type(self)




    def data_type(self):

        localctx = ExprParser.Data_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_data_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 3840) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Insert_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ExprParser.IDENTIFIER, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(ExprParser.Identifier_listContext,0)


        def value_list(self):
            return self.getTypedRuleContext(ExprParser.Value_listContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_insert_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsert_statement" ):
                listener.enterInsert_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsert_statement" ):
                listener.exitInsert_statement(self)




    def insert_statement(self):

        localctx = ExprParser.Insert_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_insert_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self.match(ExprParser.T__11)
            self.state = 103
            self.match(ExprParser.IDENTIFIER)
            self.state = 104
            self.match(ExprParser.T__1)
            self.state = 105
            self.identifier_list()
            self.state = 106
            self.match(ExprParser.T__2)
            self.state = 107
            self.match(ExprParser.T__12)
            self.state = 108
            self.match(ExprParser.T__1)
            self.state = 109
            self.value_list()
            self.state = 110
            self.match(ExprParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Update_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ExprParser.IDENTIFIER, 0)

        def assignment_list(self):
            return self.getTypedRuleContext(ExprParser.Assignment_listContext,0)


        def where_clause(self):
            return self.getTypedRuleContext(ExprParser.Where_clauseContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_update_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdate_statement" ):
                listener.enterUpdate_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdate_statement" ):
                listener.exitUpdate_statement(self)




    def update_statement(self):

        localctx = ExprParser.Update_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_update_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self.match(ExprParser.T__13)
            self.state = 113
            self.match(ExprParser.IDENTIFIER)
            self.state = 114
            self.match(ExprParser.T__14)
            self.state = 115
            self.assignment_list()
            self.state = 116
            self.where_clause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Delete_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ExprParser.IDENTIFIER, 0)

        def where_clause(self):
            return self.getTypedRuleContext(ExprParser.Where_clauseContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_delete_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelete_statement" ):
                listener.enterDelete_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelete_statement" ):
                listener.exitDelete_statement(self)




    def delete_statement(self):

        localctx = ExprParser.Delete_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_delete_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 118
            self.match(ExprParser.T__15)
            self.state = 119
            self.match(ExprParser.IDENTIFIER)
            self.state = 120
            self.where_clause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selection(self):
            return self.getTypedRuleContext(ExprParser.SelectionContext,0)


        def IDENTIFIER(self):
            return self.getToken(ExprParser.IDENTIFIER, 0)

        def join_clause(self):
            return self.getTypedRuleContext(ExprParser.Join_clauseContext,0)


        def where_clause(self):
            return self.getTypedRuleContext(ExprParser.Where_clauseContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_select_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_statement" ):
                listener.enterSelect_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_statement" ):
                listener.exitSelect_statement(self)




    def select_statement(self):

        localctx = ExprParser.Select_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_select_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self.match(ExprParser.T__16)
            self.state = 123
            self.selection()
            self.state = 124
            self.match(ExprParser.T__17)
            self.state = 125
            self.match(ExprParser.IDENTIFIER)
            self.state = 126
            self.join_clause()
            self.state = 127
            self.where_clause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Where_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(ExprParser.ConditionContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_where_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhere_clause" ):
                listener.enterWhere_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhere_clause" ):
                listener.exitWhere_clause(self)




    def where_clause(self):

        localctx = ExprParser.Where_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_where_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.match(ExprParser.T__18)
            self.state = 130
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Join_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ExprParser.IDENTIFIER, 0)

        def condition(self):
            return self.getTypedRuleContext(ExprParser.ConditionContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_join_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoin_clause" ):
                listener.enterJoin_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoin_clause" ):
                listener.exitJoin_clause(self)




    def join_clause(self):

        localctx = ExprParser.Join_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_join_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.match(ExprParser.T__19)
            self.state = 133
            self.match(ExprParser.IDENTIFIER)
            self.state = 134
            self.match(ExprParser.T__20)
            self.state = 135
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExprParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(ExprParser.ExpressionContext,i)


        def logical_operator(self):
            return self.getTypedRuleContext(ExprParser.Logical_operatorContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)




    def condition(self):

        localctx = ExprParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_condition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.expression()
            self.state = 138
            self.logical_operator()
            self.state = 139
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Logical_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ExprParser.RULE_logical_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogical_operator" ):
                listener.enterLogical_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogical_operator" ):
                listener.exitLogical_operator(self)




    def logical_operator(self):

        localctx = ExprParser.Logical_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_logical_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            _la = self._input.LA(1)
            if not(_la==22 or _la==23):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ExprParser.IDENTIFIER, 0)

        def value(self):
            return self.getTypedRuleContext(ExprParser.ValueContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)




    def expression(self):

        localctx = ExprParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_expression)
        try:
            self.state = 145
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [32]:
                self.enterOuterAlt(localctx, 1)
                self.state = 143
                self.match(ExprParser.IDENTIFIER)
                pass
            elif token in [24, 27, 28, 30, 31]:
                self.enterOuterAlt(localctx, 2)
                self.state = 144
                self.value()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numerical_literal(self):
            return self.getTypedRuleContext(ExprParser.Numerical_literalContext,0)


        def string_literal(self):
            return self.getTypedRuleContext(ExprParser.String_literalContext,0)


        def boolean_literal(self):
            return self.getTypedRuleContext(ExprParser.Boolean_literalContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue" ):
                listener.enterValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue" ):
                listener.exitValue(self)




    def value(self):

        localctx = ExprParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_value)
        try:
            self.state = 151
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [27]:
                self.enterOuterAlt(localctx, 1)
                self.state = 147
                self.numerical_literal()
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 2)
                self.state = 148
                self.string_literal()
                pass
            elif token in [30, 31]:
                self.enterOuterAlt(localctx, 3)
                self.state = 149
                self.boolean_literal()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 4)
                self.state = 150
                self.match(ExprParser.T__23)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Identifier_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ExprParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return ExprParser.RULE_identifier_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier_list" ):
                listener.enterIdentifier_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier_list" ):
                listener.exitIdentifier_list(self)




    def identifier_list(self):

        localctx = ExprParser.Identifier_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_identifier_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 153
            self.match(ExprParser.IDENTIFIER)
            self.state = 157
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==7:
                self.state = 154
                self.match(ExprParser.T__6)
                self.state = 159
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Value_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def value(self):
            return self.getTypedRuleContext(ExprParser.ValueContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_value_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue_list" ):
                listener.enterValue_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue_list" ):
                listener.exitValue_list(self)




    def value_list(self):

        localctx = ExprParser.Value_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_value_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            self.value()
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==7:
                self.state = 161
                self.match(ExprParser.T__6)
                self.state = 166
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Assignment_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(ExprParser.IDENTIFIER, 0)

        def value(self):
            return self.getTypedRuleContext(ExprParser.ValueContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_assignment_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment_list" ):
                listener.enterAssignment_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment_list" ):
                listener.exitAssignment_list(self)




    def assignment_list(self):

        localctx = ExprParser.Assignment_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_assignment_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            self.match(ExprParser.IDENTIFIER)
            self.state = 168
            self.match(ExprParser.T__24)
            self.state = 169
            self.value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier_list(self):
            return self.getTypedRuleContext(ExprParser.Identifier_listContext,0)


        def getRuleIndex(self):
            return ExprParser.RULE_selection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelection" ):
                listener.enterSelection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelection" ):
                listener.exitSelection(self)




    def selection(self):

        localctx = ExprParser.SelectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_selection)
        try:
            self.state = 173
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [26]:
                self.enterOuterAlt(localctx, 1)
                self.state = 171
                self.match(ExprParser.T__25)
                pass
            elif token in [32]:
                self.enterOuterAlt(localctx, 2)
                self.state = 172
                self.identifier_list()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numerical_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(ExprParser.DIGIT)
            else:
                return self.getToken(ExprParser.DIGIT, i)

        def getRuleIndex(self):
            return ExprParser.RULE_numerical_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumerical_literal" ):
                listener.enterNumerical_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumerical_literal" ):
                listener.exitNumerical_literal(self)




    def numerical_literal(self):

        localctx = ExprParser.Numerical_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_numerical_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            self.match(ExprParser.T__26)
            self.state = 177 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 176
                self.match(ExprParser.DIGIT)
                self.state = 179 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==33):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class String_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ExprParser.RULE_string_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString_literal" ):
                listener.enterString_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString_literal" ):
                listener.exitString_literal(self)




    def string_literal(self):

        localctx = ExprParser.String_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_string_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self.match(ExprParser.T__27)
            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 67914170366) != 0):
                self.state = 182
                _la = self._input.LA(1)
                if _la <= 0 or _la==28 or _la==29:
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 187
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 188
            self.match(ExprParser.T__27)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Boolean_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ExprParser.RULE_boolean_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolean_literal" ):
                listener.enterBoolean_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolean_literal" ):
                listener.exitBoolean_literal(self)




    def boolean_literal(self):

        localctx = ExprParser.Boolean_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_boolean_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            _la = self._input.LA(1)
            if not(_la==30 or _la==31):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





